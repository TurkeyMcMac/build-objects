#!/usr/bin/perl
#
# This file is a script for simplifying the building of C/C++ projects that use
# Makefiles. It works with non-GNU make implementations and compilers including
# GCC, Clang, and TinyCC.
#
# MIT License
#
# Copyright (c) 2020 Jude Melton-Houghton
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

use strict;
use warnings;
use Getopt::Std;

my $progname = $0;

$Getopt::Std::STANDARD_HELP_VERSION = 1;

sub HELP_MESSAGE {
	print <<EOT;

Usage: $progname [<options>] [--] <cc> <cc-args>

Compile a directory's C/C++ source files into object files in another directory.
Header dependencies are tracked. This script can be used in Makefiles like so:
  release-executable: src/*
          \@$progname -s src -b build/release \$(CC) \$(CFLAGS)
          \$(CC) -o \$@ build/release/*.o \$(LDLIBS)

Options:
  -s <dir>  Set the source code directory. The default is 'src'.
  -b <dir>  Set the build directory. The default is 'build'.
  -j <num>  Set the number of processors to use for compiling. The default is 1.
  -j auto   Use processors equal to the number available on the computer.
  -e <list> Only consider as compilation units files with extensions from the
            given comma-separated list. The default is 'c,cc,cpp,cxx,C,CPP,m'.
  -h        Print this help information and exit.
  -v        Print the script version and exit.
EOT
}

sub VERSION_MESSAGE {
	print "$progname version 0.0.1\n";
}

# Makes a path safe for command arguments, adding a './' if it begins with '-'.
sub make_path_safe {
	local ($_) = @_;
	s|^-|./-|;
	return $_;
}

# Tries to find the number of available processors on the computer.
sub get_n_processors {
	# nproc is part of GNU coreutils, but it's also in Busybox. It is
	# probably present on Mac, but the sysctl works for Mac just in case.
	# Support for more systems can be added here.
	my $out = `sh -c 'nproc || sysctl -n hw.ncpu' 2>/dev/null`;
	return $out if $out ne '';

	# Use Sys::Info if it's installed (but it seems slower than the above.)
	if (eval('require Sys::Info')) {
		return Sys::Info->new->device("CPU")->count;
	}

	# 4 is a safe default:
	print(STDERR "$progname: Warning: Cannot determine processor count ",
		"automatically; assuming there are 4 processors\n");
	return 4;
}

# Checks if a path ends with one of the given suffixes (after a dot.)
sub matches_endings {
	my ($str, @endings) = @_;
	foreach my $ending (@endings) {
		return 1 if $str =~ /\.(.*)$/ && $1 eq $ending;
	}
	return 0;
}

# Gets the contents at the path as a string, dying if that is not possible.
sub get_file_contents {
	my ($path) = @_;
	open(my $file, '<', $path) or die("$path: $!");
	local $/;
	return <$file>;
}

# Parses the given contents of a file generated by -MD. The return value is an
# array of paths. The function tries to deal with escaped characters, but these
# are not very consistent across compilers. Most includes don't have escapes.
sub parse_deps {
	my ($deps_str) = @_;
	# Remove line breaks:
	$deps_str =~ s/\\\n//gm;
	# Capture just the prerequisites, not the target:
	if ($deps_str =~ /(?:.*[^\\])?:\s*(.*)/) {
		my $prereq_str = $1;
		# Split the paths and unescape them:
		my @prereqs = map { s/\\(.)/$1/g; $_ }
			split(/(?<!\\)\s+/, $prereq_str);
		return @prereqs;
	}
	return ();
}

# Gets the mtime of a path from the system or from its cache. Caching should be
# fine since it is assumed that no files are being modified during the running
# of this script.
my %cached_mtimes = ();
sub mtime {
	my ($path) = @_;
	my $cached_mtime = $cached_mtimes{$path};
	if (defined($cached_mtime)) {
		return $cached_mtime;
	} else {
		my @stat = stat($path);
		my $mtime = @stat ? $stat[9] : 0;
		$cached_mtimes{$path} = $mtime;
		return $mtime;
	}
}

# Parse the options:
my %opts;
getopts('s:b:j:e:hv', \%opts) or die('Aborting');
if (defined($opts{h})) {
	VERSION_MESSAGE();
	HELP_MESSAGE();
	exit(0);
}
if (defined($opts{v})) {
	VERSION_MESSAGE();
	exit(0);
}
my $src_path = make_path_safe($opts{s} // 'src');
my $build_path = make_path_safe($opts{b} // 'build');
my $max_procs = $opts{j} // '1';
my @file_endings = split(',', $opts{e} // 'c,cc,cpp,cxx,C,CPP,m');
my @generic_cc_argv = @ARGV;
if ($max_procs eq 'auto') {
	$max_procs = get_n_processors();
} elsif ($max_procs !~ /^[0-9]+$/ || $max_procs <= 0) {
	print(STDERR "$progname: -j must be given a positive integer, ",
		"or 'auto'\n");
	die('Aborted');
}

# Prepare to do stuff with the directories:
system('mkdir', '-p', $build_path) and die('Failed');
opendir(my $src_dir, $src_path) or die("$src_path: $!");

# Collect the compilation units that need rebuilding:
my @rebuilds = ();
while (my $src_file = readdir($src_dir)) {
	# Only consider files with the right suffixes:
	next if -d($src_file) || !matches_endings($src_file, @file_endings);

	my $input = "$src_path/$src_file";
	my $output = "$build_path/$src_file.o";
	my $deps = "$build_path/$src_file.d";

	# Rebuild if the source file has been modified:
	my $do_rebuild = mtime($input) > mtime($output);
	unless ($do_rebuild) {
		# Rebuild if a prerequisite has been changed (or doesn't exist):
		my @prereqs = -f($deps) ?
			parse_deps(get_file_contents($deps)) : ();
		foreach my $prereq (@prereqs) {
			if (!-e($prereq) || mtime($prereq) > mtime($output)) {
				$do_rebuild = 1;
				last;
			}
		}
	}
	# Remember the information to rebuild the unit below:
	push(@rebuilds, [$input, $output, $deps]) if $do_rebuild;
}

# Rebuild the sources:
my $n_procs = 0; # This is the number of compilation processes currently going.
foreach my $rebuild (@rebuilds) {
	# Wait until a processor is available:
	if ($n_procs >= $max_procs) {
		wait();
		# Die if a compiler dies:
		die('Failed') if $? != 0;
		--$n_procs;
	}
	my ($input, $output, $deps) = @$rebuild;
	my @child_argv = (@generic_cc_argv, '-MD', '-MF', $deps, '-c',
		'-o', $output, $input);
	# Print the command to be executed:
	print((join ' ', @child_argv), "\n");
	my $pid = fork();
	if ($pid == 0) {
		exec(@child_argv);
		# If exec fails, it seems to print an error message on its own.
		exit(1);
	} elsif ($pid < 0) {
		die($!);
	} else {
		++$n_procs;
	}
}
# After all compilers have been at least started, wait for everything to finish:
while ($n_procs > 0) {
	wait();
	die('Failed') if $? != 0;
	--$n_procs;
}
