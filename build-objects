#!/usr/bin/perl
#
# This file is a script for simplifying the building of C/C++ projects that use
# Makefiles. It works with non-GNU make implementations and compilers including
# GCC, Clang, and TinyCC.
#
# MIT License
#
# Copyright (c) 2020 Jude Melton-Houghton
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

use strict;
use warnings;
use Getopt::Std;

my $progname = $0;

# Makes a path safe for command arguments, adding a './' if it begins with '-'.
sub make_path_safe {
	local ($_) = @_;
	s|^-|./-|;
	return $_;
}

# Tries to find the number of available processors on the computer.
sub get_n_processors {
	if (eval('require Sys::Info')) {
		return Sys::Info->new->device("CPU")->count;
	} else {
		# nproc is part of GNU coreutils, but it's also in Busybox. It
		# is probably present on Mac, but the sysctl works for Mac just
		# in case. Support for more systems can be added here.
		my $out = `sh -c 'nproc || sysctl -n hw.ncpu' 2>/dev/null`;
		return $out if $out ne '';
	};
	# 4 is a safe default:
	print(STDERR "$progname: Warning: Cannot determine processor count ",
		"automatically; assuming there are 4 processors\n");
	return 4;
}

# Gets the contents at the path as a string, dying if that is not possible.
sub get_file_contents {
	my ($path) = @_;
	open(my $file, '<', $path) or die("$path: $!");
	local $/;
	return <$file>;
}

# Parses the given contents of a file generated by -MD. The return value is an
# array of paths. The function tries to deal with escaped characters, but these
# are not very consistent across compilers. Most includes don't have escapes.
sub parse_deps {
	my ($deps_str) = @_;
	# Remove line breaks:
	$deps_str =~ s/\\\n//gm;
	# Capture just the prerequisites, not the target:
	if ($deps_str =~ /(?:.*[^\\])?:\s*(.*)/) {
		my $prereq_str = $1;
		# Split the paths and unescape them:
		my @prereqs = map { s/\\(.)/$1/g; $_ }
			split(/(?<!\\)\s+/, $prereq_str);
		return @prereqs;
	}
	return ();
}

# Gets the mtime of a path from the system or from its cache. Caching should be
# fine since it is assumed that no files are being modified during the running
# of this script.
my %cached_mtimes = ();
sub mtime {
	my ($path) = @_;
	my $cached_mtime = $cached_mtimes{$path};
	if (defined($cached_mtime)) {
		return $cached_mtime;
	} else {
		my @stat = stat($path);
		my $mtime = @stat ? $stat[9] : 0;
		$cached_mtimes{$path} = $mtime;
		return $mtime;
	}
}

# Parse the options:
my %opts;
getopts('s:b:j:', \%opts) or die('Aborting');
my $src_path = make_path_safe($opts{s} // 'src');
my $build_path = make_path_safe($opts{b} // 'build');
my $max_procs = $opts{j} // '1';
my @generic_cc_argv = @ARGV;
if ($max_procs eq 'auto') {
	$max_procs = get_n_processors();
} elsif ($max_procs !~ /^[0-9]+$/ || $max_procs <= 0) {
	print(STDERR "$progname: -j must be given a positive integer, ",
		"or 'auto'\n");
	die('Aborted');
}

# Prepare to do stuff with the directories:
system('mkdir', '-p', $build_path) and die('Failed');
opendir(my $src_dir, $src_path) or die("$src_path: $!");

# Collect the compilation units that need rebuilding:
my @rebuilds = ();
while (my $src_file = readdir($src_dir)) {
	# Only consider files with the right suffixes:
	next if -d($src_file) || $src_file !~ /\.(?:c|cc|cpp|cxx|C|CPP|m)$/;

	my $input = "$src_path/$src_file";
	my $output = "$build_path/$src_file.o";
	my $deps = "$build_path/$src_file.d";

	# Rebuild if the source file has been modified:
	my $do_rebuild = mtime($input) > mtime($output);
	unless ($do_rebuild) {
		# Rebuild if a prerequisite has been changed (or doesn't exist):
		my @prereqs = -f($deps) ?
			parse_deps(get_file_contents($deps)) : ();
		foreach my $prereq (@prereqs) {
			if (!-e($prereq) || mtime($prereq) > mtime($output)) {
				$do_rebuild = 1;
				last;
			}
		}
	}
	# Remember the information to rebuild the unit below:
	push(@rebuilds, [$input, $output, $deps]) if $do_rebuild;
}

# Rebuild the sources:
my $n_procs = 0; # This is the number of compilation processes currently going.
foreach my $rebuild (@rebuilds) {
	# Wait until a processor is available:
	if ($n_procs >= $max_procs) {
		wait();
		# Die if a compiler dies:
		die('Failed') if $? != 0;
		--$n_procs;
	}
	my ($input, $output, $deps) = @$rebuild;
	my @child_argv = (@generic_cc_argv, '-MD', '-MF', $deps, '-c',
		'-o', $output, $input);
	# Print the command to be executed:
	print((join ' ', @child_argv), "\n");
	my $pid = fork();
	if ($pid == 0) {
		exec(@child_argv);
		# If exec failes, it seems to print an error message on its own.
		exit(1);
	} elsif ($pid < 0) {
		die($!);
	} else {
		++$n_procs;
	}
}
# After all compilers have been at least started, wait for everything to finish:
while ($n_procs > 0) {
	wait();
	die('Failed') if $? != 0;
	--$n_procs;
}
